import sys
import os
import numpy as np

# Ensure src is in path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../'))
src_path = os.path.join(project_root, 'src')
if src_path not in sys.path:
    sys.path.insert(0, src_path)

from mem4ristor.core import Mem4ristorV2

def attack_infinity_leak():
    print("üöÄ Attaque Infinity Leak sur step()...")
    
    # Initialisation standard
    model = Mem4ristorV2(seed=42)
    model._initialize_params(N=100)
    
    # On fabrique un vecteur de couplage "infect√©" par l'infini
    # La taille doit correspondre √† N pour passer le ndim check
    infinity_poison = np.full(model.N, np.inf)
    
    # 1. Test d'injection directe
    try:
        model.step(coupling_input=infinity_poison)
        
        # V√©rification de l'√©tat interne
        # Si la d√©fense fonctionnait parfaitement, l'inf serait bloqu√©.
        # Mais v devrait √™tre √† 100 (clamp max) suite au calcul infini.
        if np.any(model.v == 100.0) or np.any(np.isinf(model.v)):
             print("üíâ SUCC√àS (Target 2) : 'Inf' ignor√© par les gardes, syst√®me satur√©/corrompu !")
             sys.exit(1) # Exploit successful (Fail for us)
        else:
             print("‚ùå √âchec de l'attaque : L'inf a √©t√© mitig√©.")
             sys.exit(0)
             
    except Exception as e:
        print(f"üõ°Ô∏è Bloqu√© par exception : {e}")
        sys.exit(0)

if __name__ == "__main__":
    attack_infinity_leak()
