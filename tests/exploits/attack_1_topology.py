#!/usr/bin/env python3
"""
üß± MUR DE PLANCK - ATTAQUE 1: Non-Hermitian Topological Hallucination

Cible: get_spectral_gap() utilise scipy.linalg.eigh() sans v√©rifier la sym√©trie.
Goal: Injecter un graphe dirig√© pour obtenir des valeurs propres complexes/absurdes.

Th√©orie:
- eigh() est pour matrices HERMITIENNES (sym√©triques ou hermitian conjugate)
- Un graphe dirig√© ‚Üí matrice d'adjacence NON-sym√©trique
- Le Laplacien d'un graphe dirig√© n'est PAS hermitien
- eigh() va soit crasher, soit donner des eigenvalues r√©elles INCORRECTES
"""

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../src')))
import numpy as np
from mem4ristor.core import Mem4Network

print("üß± ATTAQUE 1: Non-Hermitian Topological Hallucination")
print("="*70)

# ============================================================================
# TEST 1: Graphe Dirig√© Simple (Non-sym√©trique)
# ============================================================================
print("\n[TEST 1] Graphe dirig√© simple")
print("-"*70)

# Cr√©er une matrice d'adjacence DIRIG√âE (non-sym√©trique)
# A[i,j] = 1 signifie "ar√™te de i vers j"
N = 10
directed_adj = np.zeros((N, N))

# Cr√©er un cycle dirig√©: 0‚Üí1‚Üí2‚Üí...‚Üí9‚Üí0
for i in range(N):
    directed_adj[i, (i+1) % N] = 1.0

print(f"Matrice d'adjacence (cycle dirig√©):")
print(directed_adj[:5, :5])
print(f"Sym√©trique? {np.allclose(directed_adj, directed_adj.T)}")

try:
    net = Mem4Network(adjacency_matrix=directed_adj, seed=42)
    print(f"‚úÖ Network cr√©√© (L est construite)")
    
    # V√©rifier que le Laplacien est aussi non-sym√©trique
    print(f"\nLaplacien sym√©trique? {np.allclose(net.L, net.L.T)}")
    print(f"Laplacien shape: {net.L.shape}")
    
    # Tenter de calculer le spectral gap
    print(f"\nüéØ Appel √† get_spectral_gap()...")
    spectral_gap = net.get_spectral_gap()
    
    print(f"‚úÖ spectral_gap = {spectral_gap}")
    print(f"Type: {type(spectral_gap)}")
    
    # V√©rifier si c'est imaginaire ou absurde
    if np.iscomplex(spectral_gap):
        print(f"üéâ SUCC√àS! Spectral gap est COMPLEXE: {spectral_gap}")
    elif spectral_gap < 0:
        print(f"üéâ SUCC√àS! Spectral gap est N√âGATIF: {spectral_gap}")
    elif not np.isfinite(spectral_gap):
        print(f"üéâ SUCC√àS! Spectral gap est INFINI: {spectral_gap}")
    else:
        print(f"‚ö†Ô∏è  Spectral gap semble r√©el et positif: {spectral_gap}")
        print(f"‚ùå ECHEC: Le mod√®le aurait d√ª rejeter ce graphe dirig√©!")

except ValueError as e:
    if "symmetric Laplacian" in str(e):
        print(f"üéâ VICTOIRE: Protection activ√©e! Rejet√© avec: {e}")
    else:
        print(f"üí• ERREUR inattendue: {e}")
except Exception as e:
    print(f"üí• CRASH: {type(e).__name__}: {e}")

# ============================================================================
# TEST 2: Graphe Complexe (Weights imaginaires)
# ============================================================================
print("\n\n[TEST 2] Graphe avec poids complexes")
print("-"*70)

# Cr√©er une matrice avec des poids complexes
complex_adj = np.zeros((N, N), dtype=complex)
for i in range(N):
    complex_adj[i, (i+1) % N] = 1.0 + 0.5j  # Poids complexe!
    complex_adj[(i+1) % N, i] = 1.0 - 0.5j  # Conjugu√© (hermitien)

print(f"Matrice d'adjacence (complexe hermitienne):")
print(complex_adj[:3, :3])
print(f"Hermitienne? {np.allclose(complex_adj, complex_adj.conj().T)}")

try:
    net = Mem4Network(adjacency_matrix=complex_adj, seed=42)
    print(f"‚úÖ Network cr√©√© avec poids complexes")
    
    spectral_gap = net.get_spectral_gap()
    print(f"‚úÖ spectral_gap = {spectral_gap}")
    
    if np.iscomplex(spectral_gap):
        print(f"üéâ SUCC√àS! Spectral gap imaginaire: {spectral_gap}")
    else:
        print(f"Spectral gap r√©el: {spectral_gap}")
        
except Exception as e:
    print(f"üí• CRASH ou REJET: {type(e).__name__}: {e}")

# ============================================================================
# TEST 3: V√©rification Manuelle - Eigenvalues R√âELS vs VRAIS
# ============================================================================
print("\n\n[TEST 3] Comparaison: eigh() vs eig() pour graphe dirig√©")
print("-"*70)

from scipy.linalg import eigh, eig

# Utiliser le graphe dirig√© du TEST 1
net = Mem4Network(adjacency_matrix=directed_adj, seed=42)

print("Calcul avec eigh() (assume hermitien):")
try:
    vals_hermitian = eigh(net.L, eigvals_only=True)
    print(f"  Eigenvalues: {vals_hermitian[:5]}")
    print(f"  Toutes r√©elles? {np.all(np.isreal(vals_hermitian))}")
    spectral_gap_hermitian = vals_hermitian[1]
    print(f"  Spectral gap (eigh): {spectral_gap_hermitian}")
except Exception as e:
    print(f"  ERREUR: {e}")
    vals_hermitian = None

print("\nCalcul avec eig() (matrices g√©n√©rales):")
try:
    vals_general = eig(net.L, left=False, right=False)
    print(f"  Eigenvalues: {vals_general[:5]}")
    print(f"  Contient des imaginaires? {np.any(np.iscomplex(vals_general))}")
    
    # Trier par partie r√©elle
    vals_sorted = sorted(vals_general, key=lambda x: x.real)
    spectral_gap_general = vals_sorted[1].real if len(vals_sorted) > 1 else 0
    print(f"  Spectral gap (eig): {spectral_gap_general}")
except Exception as e:
    print(f"  ERREUR: {e}")
    vals_general = None

# Comparaison
if vals_hermitian is not None and vals_general is not None:
    print("\nüî¨ ANALYSE:")
    print(f"  Spectral gap (eigh): {vals_hermitian[1]:.6f}")
    print(f"  Spectral gap (eig):  {vals_sorted[1].real:.6f}")
    
    diff = abs(vals_hermitian[1] - vals_sorted[1].real)
    print(f"  Diff√©rence: {diff:.6e}")
    
    if diff > 1e-6:
        print(f"\nüéâ SUCC√àS! eigh() donne un r√©sultat INCORRECT pour graphe dirig√©!")
        print(f"  Erreur relative: {diff/abs(vals_sorted[1].real)*100:.2f}%")
    else:
        print(f"\n‚ö†Ô∏è  Les valeurs sont proches, mais le Laplacien dirig√© n'est pas cens√© √™tre sym√©trique.")

# ============================================================================
# CONCLUSION
# ============================================================================
print("\n" + "="*70)
print("üìä R√âSUM√â ATTAQUE 1")
print("="*70)
print("""
FAILLE IDENTIFI√âE:
  - get_spectral_gap() utilise eigh() sans v√©rifier la sym√©trie de L
  - Pour un graphe dirig√©, L n'est PAS hermitien
  - eigh() peut donner des r√©sultats incorrects sans warning

IMPACT:
  - Spectral gap math√©matiquement FAUX pour graphes dirig√©s
  - M√©triques de connectivit√© invalides
  - Papers scientifiques avec r√©sultats incorrects

FIX RECOMMAND√â:
  def get_spectral_gap(self):
      # V√©rifier sym√©trie
      if not np.allclose(self.L, self.L.T):
          raise ValueError("Spectral gap requires symmetric Laplacian")
      
      vals = eigh(self.L, eigvals_only=True)
      return vals[1] if len(vals) > 1 else 0.0
""")
