import sys
import os

# Ensure src is in path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../'))
src_path = os.path.join(project_root, 'src')
if src_path not in sys.path:
    sys.path.insert(0, src_path)

from mem4ristor.core import Mem4ristorV2

def attack_circular_config():
    print("üöÄ Lancement de l'attaque Circular Config...")
    
    # Create circular reference
    config = {'dynamics': {}}
    config['dynamics']['nested'] = config # This key 'nested' is NOT in default_cfg['dynamics']
    # _deep_merge only recurses if key is in base AND matches type dict.
    # default_cfg['dynamics'] is flat {a, b...}. No sub-dicts.
    # So recursion creates a reference assignment but not a recursive CALL.
    
    try:
        print("‚öôÔ∏è Appel de Mem4ristorV2 avec config circulaire...")
        model = Mem4ristorV2(config=config)
        print("‚ùå √âchec de l'attaque : Le mod√®le a g√©r√© la circularit√©.")
        sys.exit(0)
        
    except RecursionError:
        print("üí• CRASH R√âUSSI (Target 1) : RecursionError (Stack Overflow via Circular Ref).")
        sys.exit(1)
    except ValueError as e:
        if "Circular" in str(e) or "nesting" in str(e):
             print(f"üõ°Ô∏è D√©fense active (V5 Success) : {e}")
             sys.exit(0)
        print(f"‚ö†Ô∏è Autre ValueError : {e}")
        sys.exit(0)
    except Exception as e:
        print(f"‚ö†Ô∏è Autre erreur : {type(e).__name__} : {e}")
        sys.exit(0)

if __name__ == "__main__":
    attack_circular_config()
