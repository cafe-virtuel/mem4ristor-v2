#!/usr/bin/env python3
"""
üß± MUR DE PLANCK - ATTAQUE 2: Singularit√© Num√©rique (Stiff System)

Cible: solve_rk45() utilise RK45 (m√©thode EXPLICITE) sans d√©tection de stiffness.
Goal: Cr√©er un syst√®me si raide que le pas de temps dt ‚Üí 0, causant un gel (Zeno).

Th√©orie:
- Un syst√®me est "stiff" quand il a des √©chelles de temps tr√®s diff√©rentes
- RK45 (explicite) doit prendre dt ‚â™ 1/Œª_max pour √™tre stable
- Si on cr√©e Œµ ‚Üí 0 avec couplage fort, on a Œª_max ‚Üí ‚àû
- Le solveur va prendre des pas infinit√©simaux ‚Üí gel ou explosion

Recette pour la raideur:
1. epsilon_u tr√®s petit (ex: 1e-8) ‚Üí s√©paration d'√©chelle temporelle
2. Couplage D tr√®s fort (ex: 100) ‚Üí dynamique rapide
3. tau_u tr√®s petit (ex: 1e-6) ‚Üí division par petit nombre
"""

import time
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../src')))
import numpy as np
from mem4ristor.core import Mem4ristorV2

print("üß± ATTAQUE 2: Singularit√© Num√©rique - Zeno's Paradox")
print("="*70)

# ============================================================================
# TEST 1: Syst√®me Stiff Extr√™me
# ============================================================================
print("\n[TEST 1] Configuration ultra-stiff")
print("-"*70)

config_stiff = {
    'dynamics': {
        'epsilon': 1e-8,  # Tr√®s petit ‚Üí s√©paration d'√©chelle
        'alpha': 0.15,
        'dt': 0.01
    },
    'coupling': {
        'D': 100.0  # Couplage FORT ‚Üí dynamique rapide
    },
    'doubt': {
        'epsilon_u': 1e-9,  # Doute √©volue tr√®s lentement
        'tau_u': 1e-7,      # Division par tr√®s petit nombre
        'k_u': 100.0        # Amplification du stress social
    }
}

print("Configuration:")
print(f"  epsilon = {config_stiff['dynamics']['epsilon']}")
print(f"  epsilon_u = {config_stiff['doubt']['epsilon_u']}")
print(f"  tau_u = {config_stiff['doubt']['tau_u']}")
print(f"  D = {config_stiff['coupling']['D']}")
print(f"  Ratio epsilon/tau_u = {config_stiff['doubt']['epsilon_u'] / config_stiff['doubt']['tau_u']}")

model = Mem4ristorV2(config=config_stiff, seed=42)
model._initialize_params(N=20)  # Petit r√©seau pour debug

# Cr√©er couplage fort
adj = np.ones((20, 20)) - np.eye(20)  # Full connectivity

print(f"\nTentative d'int√©gration sur [0, 1] avec RK45...")
start = time.time()

try:
    sol = model.solve_rk45(
        t_span=(0.0, 1.0),  # Juste 1 seconde de simulation
        I_stimulus=1.0,
        adj_matrix=adj
    )
    elapsed = time.time() - start
    
    print(f"‚úÖ Termin√© en {elapsed:.3f}s")
    print(f"Nombre de points √©valu√©s: {len(sol.t)}")
    print(f"Nombre d'√©valuations de f: {sol.nfev}")
    print(f"Pas de temps moyen: {1.0 / len(sol.t):.2e}")
    print(f"Pas de temps minimum: {np.min(np.diff(sol.t)):.2e}")
    
    if elapsed > 10:
        print(f"\n‚ö†Ô∏è  ALERTE - Temps de calcul long ({elapsed:.1f}s). V√©rifier si le warning Stiffness est apparu.")
        # Note: Avec max_step, √ßa peut √™tre long, mais "safe" (pr√©cis). L'important est le warning.
    else:
        print(f"\n‚úÖ Termin√© rapidement ({elapsed:.1f}s). DoS √©vit√©?")
        
except Exception as e:
    elapsed = time.time() - start
    print(f"üí• CRASH apr√®s {elapsed:.3f}s: {type(e).__name__}: {str(e)[:100]}")

# ============================================================================
# TEST 2: Oscillations de Haute Fr√©quence
# ============================================================================
print("\n\n[TEST 2] Oscillations haute fr√©quence (forcing rapide)")
print("-"*70)

config_oscillating = {
    'dynamics': {
        'epsilon': 0.001,  # Petit mais pas extr√™me
        'b': 0.8,
        'alpha': 5.0  # Fort amortissement non-lin√©aire ‚Üí raideur
    },
    'coupling': {
        'D': 50.0
    },
    'doubt': {
        'tau_u': 0.0001  # tau tr√®s petit
    }
}

model2 = Mem4ristorV2(config=config_oscillating, seed=42)
model2._initialize_params(N=10)

adj2 = np.ones((10, 10)) - np.eye(10)

print("Int√©gration avec forcing...")
start = time.time()

try:
    sol = model2.solve_rk45(
        t_span=(0.0, 5.0),
        I_stimulus=10.0,  # Stimulus FORT
        adj_matrix=adj2
    )
    elapsed = time.time() - start
    
    print(f"‚úÖ Termin√© en {elapsed:.3f}s")
    print(f"Points: {len(sol.t)}, nfev: {sol.nfev}")
    
    # Analyser la fr√©quence
    dt_array = np.diff(sol.t)
    print(f"dt min: {dt_array.min():.2e}, max: {dt_array.max():.2e}")
    print(f"dt mean: {dt_array.mean():.2e}, std: {dt_array.std():.2e}")
    
    if dt_array.std() / dt_array.mean() > 100:
        print(f"\nüéâ SUCC√àS - Pas de temps ultra-variable (stiff signature)!")
        
except Exception as e:
    print(f"üí• CRASH: {e}")

# ============================================================================
# TEST 3: Division par Z√©ro Num√©rique (Underflow)
# ============================================================================
print("\n\n[TEST 3] Underflow catastrophique")
print("-"*70)

config_underflow = {
    'dynamics': {
        'epsilon': 1e-100,  # Au-del√† de la pr√©cision machine
        'dt': 0.01
    },
    'doubt': {
        'epsilon_u': 1e-100,
        'tau_u': 1e-100  # epsilon_u / tau_u = 1, mais les deux sous-repr√©sentables
    }
}

print("epsilon = 1e-100 (< machine epsilon ~2e-16)")
print("Que se passe-t-il avec l'arithm√©tique flottante?")

try:
    model3 = Mem4ristorV2(config=config_underflow, seed=42)
    model3._initialize_params(N=5)
    
    adj3 = np.eye(5)
    
    print("\nInt√©gration...")
    sol = model3.solve_rk45(
        t_span=(0.0, 1.0),
        I_stimulus=1.0,
        adj_matrix=adj3
    )
    
    print(f"‚úÖ Termin√©, points: {len(sol.t)}")
    
    # V√©rifier si les d√©riv√©es sont nulles (underflow ‚Üí pas de mouvement)
    v_initial = sol.y[0, 0]
    v_final = sol.y[0, -1]
    
    print(f"v[0] initial: {v_initial:.10f}")
    print(f"v[0] final:   {v_final:.10f}")
    print(f"Diff√©rence:   {abs(v_final - v_initial):.2e}")
    
    if abs(v_final - v_initial) < 1e-10:
        print(f"\nüéâ SUCC√àS - Underflow total, le syst√®me est gel√©!")
    
except Exception as e:
    print(f"üí• {type(e).__name__}: {e}")

# ============================================================================
# TEST 4: Comparaison RK45 vs m√©thode implicite
# ============================================================================
print("\n\n[TEST 4] RK45 vs Radau (m√©thode implicite)")
print("-"*70)

from scipy.integrate import solve_ivp

config_comparison = config_stiff  # R√©utiliser config stiff

model4 = Mem4ristorV2(config=config_comparison, seed=42)
model4._initialize_params(N=10)

adj4 = np.ones((10, 10)) - np.eye(10)

def combined_dynamics(t, y):
    N = 10
    v = y[:N]
    w = y[N:2*N]
    u = y[2*N:]
    
    laplacian_v = adj4 @ v - v
    sigma_social = np.abs(laplacian_v)
    
    u_filter = (1.0 - 2.0 * u)
    I_eff = np.full(N, 1.0)
    I_ext = I_eff + model4.D_eff * u_filter * laplacian_v
    
    eta = np.zeros(N)  # Pas de bruit pour comparaison
    
    dv = v - (v**3)/5.0 - w + I_ext - 0.15 * np.tanh(v) + eta
    dw = config_comparison['dynamics']['epsilon'] * (v + 0.7 - 0.8 * w)
    du = (config_comparison['doubt']['epsilon_u'] * (100.0 * sigma_social + 0.05 - u)) / config_comparison['doubt']['tau_u']
    
    return np.concatenate([dv, dw, du])

y0 = np.concatenate([model4.v, model4.w, model4.u])

print("RK45 (explicite):")
start = time.time()
try:
    sol_rk45 = solve_ivp(combined_dynamics, (0, 1), y0, method='RK45', rtol=1e-6)
    elapsed_rk45 = time.time() - start
    print(f"  Temps: {elapsed_rk45:.3f}s, nfev: {sol_rk45.nfev}, points: {len(sol_rk45.t)}")
except Exception as e:
    elapsed_rk45 = time.time() - start
    print(f"  √âCHEC apr√®s {elapsed_rk45:.3f}s: {e}")
    sol_rk45 = None

print("\nRadau (implicite, pour syst√®mes stiff):")
start = time.time()
try:
    sol_radau = solve_ivp(combined_dynamics, (0, 1), y0, method='Radau', rtol=1e-6)
    elapsed_radau = time.time() - start
    print(f"  Temps: {elapsed_radau:.3f}s, nfev: {sol_radau.nfev}, points: {len(sol_radau.t)}")
except Exception as e:
    elapsed_radau = time.time() - start
    print(f"  √âCHEC apr√®s {elapsed_radau:.3f}s: {e}")
    sol_radau = None

if sol_rk45 and sol_radau:
    print(f"\nüî¨ ANALYSE:")
    print(f"  RK45 nfev:   {sol_rk45.nfev}")
    print(f"  Radau nfev:  {sol_radau.nfev}")
    print(f"  Ratio:       {sol_rk45.nfev / sol_radau.nfev:.1f}x plus d'√©valuations")
    
    if sol_rk45.nfev > 10 * sol_radau.nfev:
        print(f"\nüéâ SUCC√àS - RK45 est INEFFICACE pour ce syst√®me stiff!")

# ============================================================================
# CONCLUSION
# ============================================================================
print("\n" + "="*70)
print("üìä R√âSUM√â ATTAQUE 2")
print("="*70)
print("""
FAILLE IDENTIFI√âE:
  - solve_rk45() utilise m√©thode EXPLICITE sans d√©tection de stiffness
  - Param√®tres mal conditionn√©s ‚Üí s√©paration d'√©chelles de temps
  - Pas de max_step limite ‚Üí explosion du co√ªt computationnel

IMPACT:
  - DoS via gel computationnel (>10s pour t_span=[0,1])
  - Underflow/overflow silencieux
  - R√©sultats num√©riquement incorrects

FIX RECOMMAND√â:
  1. Ajouter d√©tection de stiffness automatique
  2. Limiter max_step (ex: max_step=0.1)
  3. Proposer m√©thode implicite (Radau/BDF) pour syst√®mes stiff
  
  sol = solve_ivp(combined_dynamics, t_span, y0, 
                  method='RK45', rtol=1e-6,
                  max_step=0.1)  # Limite le pas maximum
""")
